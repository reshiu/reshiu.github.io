[{"title":"某某大冒险","path":"/2025/10/27/android-reserve/案例/某某大冒险/","content":"直接jadx分析.xml文件，这里有两个重要activity，一个是SplshActivity闪屏activity，去除掉之后可以不闪过该页面直接进入登录游戏界面，一个Yodo1UnityActivity是游戏的主要逻辑 先来抓包看一下吧，开代理了进不去 看一下提示信息，代理的SSL校验不通过 用frida hook一下，游戏成功进入 刚才的连接也显示正常，这个app就只有一层SSL校验 再来尝试一下内购破解，先用android studio启动调试，再执行一下购买取消 然后分析android中的logcat,这里很明显的有段报错信息并且涉及到一些敏感字眼：Pay、purchased等 再转到jadx中搜索出来分析，看得出来这个PayHelper是一个监听，应该是用于读取支付结果并处理的 看一下它的purchased方法，这个应该是用于处理支付购买结果的。很关键的信息，有一个if来处理i2的数据，虽然这里看不出来具体是怎么处理的，但知道只要不是1都会返回空。这里可以大胆猜测只有1是表示购买成功，第二个参数ProductData很容易想到是要买的物品信息 再来交叉引用一下，除了该类中的引用之外，又发现一个关键点，在一个view.Yodo1PayActivity中也引用了，这个很显而易见是点击购买的后的一个小页面 跳转过去分析，开始的这个内部类对一个按钮进行了监听，结合后面的cancel pressed知道应该是取消逻辑，想来就是”x”按钮 再来看看该类中的a方法，如开始的分析一样将2传给i再调用purchased方法，显示购买失败 那么内购破解逻辑就很显而易见了，可以直接把这个2改为1，让取消也传入成功逻辑。 apktool解包之后找到对应smali代码修改，修改如下 再用apktool编译，传入模拟器中用mt再进行签名，这里是已经去除签名校验的版本。再安装打开试验注意这里需要点此处的”X”，一旦点击确认支付就会转到webview的一个支付页面，我们的修改并没有改变里面的逻辑。 购买成功ep:这里的关键方法定位有更快捷高效的方法。但我还不熟。","categories":["android-reserve/案例"]},{"title":"Hello World","path":"/2025/09/25/hello-world/","content":"Welcome to Hexo! This is your very first post. Check documentation for more info. If you get any problems when using Hexo, you can find the answer in troubleshooting or you can ask me on GitHub. Quick StartCreate a new post$ hexo new My New Post More info: Writing Run server$ hexo server More info: Server Generate static files$ hexo generate More info: Generating Deploy to remote sites$ hexo deploy More info: Deployment"},{"title":"androiddemo","path":"/2025/09/23/android-reserve/frida/实战/androiddemo/","content":"login 打开apk进去是一个登录 jadx分析，就是a方法对用户名进行加密，加密后的结果等于密码就登录成功了 直接hook a方法，重载让它返回一个固定的值，然后我们密码再输入该值就可以登录成功了 function main() Java.perform(function() var c = Java.use(com.example.androiddemo.Activity.LoginActivity) c.a.overload(java.lang.String,java.lang.String).implementation=function(i1,i2) i1=s i2=a this.a(i1,i2) return www )setImmediate(main) 用户名任意，密码为”www”输入成功进入第一关 第一关 jadx进一步分析，还是用a方法对某个字符串加密后等于equals里面的的字符就进入第二关 老样子，hook掉a方法让它返回固定值 function main() Java.perform(function() var c= Java.use(com.example.androiddemo.Activity.FridaActivity1) c.a.implementation=function(b) return R4jSLLLLLLLLLLOrLE7/5B+Z6fsl65yj6BgC6YWz66gO6g2t65Pk6a+P65NK44NNROl0wNOLLLL= )setImmediate(main) 这里没有-f用的attch模式 第二关 jadx进一步分析，这关就是让两个bool型变量变成true就可以了 直接hook修改，一个是静态一个是非静态。其实这里有两个构造方法，主动调用一下也是可以把两个变量变为true function main() Java.perform(function() Java.choose(com.example.androiddemo.Activity.FridaActivity2, onMatch:function(obj) var Activity=Java.use(com.example.androiddemo.Activity.FridaActivity2) Activity.static_bool_var.value=true console.log(hooked) obj.bool_var.value=true , onComplete:function() ) )setImmediate(main) 注入 第三关 和上一关很像，也是把几个字段hook成true 直接用上一关的Hook脚本 function main() Java.perform(function() var Activity=Java.use(com.example.androiddemo.Activity.FridaActivity3) Activity.static_bool_var.value=true Java.choose(com.example.androiddemo.Activity.FridaActivity3, onMatch:function(obj) obj.bool_var.value=true obj.same_name_bool_var.value=true , onComplete:function() ) )setImmediate(main) 注入进入下一关 第四关 jadx分析，这几个tcheck要return ture就可以了 就是要hook这几个内部方法，用forEach进行遍历更快捷 function main() Java.perform(function() var innerclass=Java.use(com.example.androiddemo.Activity.FridaActivity4$InnerClasses) var methods=[check1,check2,check3,check4,check5,check6] methods.forEach(function(methodname) if(innerclass[methodname]) innerclass[methodname].implementation=function() return true ) ) setImmediate(main) 注入进入下一关 第五关 这关Classloader动态加载了一个.dex文件 在asserts下面可以找到，反编译一下，里面只有一个check，应该是要让它返回true hook掉，要先执行动态加载dex的方法，让它加载到内存中，再切换类加载器不然找不到目标类,最后正常hook就可以了 function main() Java.perform(function() Java.choose(com.example.androiddemo.Activity.FridaActivity5, onMatch: function (instance) instance.getDynamicDexCheck() , onComplete: function () ); //hook 动态加载的dex Java.enumerateClassLoaders( onMatch: function (loader) Java.classFactory.loader = loader; //切换classloader , onComplete: function () ); var DynamicCheck = Java.use(com.example.androiddemo.Dynamic.DynamicCheck); DynamicCheck.check.implementation = function () return true; )setImmediate(main) 注入进入下一关 第六关 jadx分析，让导入的几个check返回true 导入的check都长这样 直接hook function main() Java.perform(function() var Class0 = Java.use(com.example.androiddemo.Activity.Frida6.Frida6Class0); Class0.check.implementation = function() return true; ; var Class1 = Java.use(com.example.androiddemo.Activity.Frida6.Frida6Class1); Class1.check.implementation = function() return true; ; var Class2 = Java.use(com.example.androiddemo.Activity.Frida6.Frida6Class2); Class2.check.implementation = function() return true; ;)setImmediate(main) 注入进入下一关，结束","categories":["android-reserve/frida/实战"]},{"title":"Challenge 0x9","path":"/2025/09/23/android-reserve/frida/实战/Challenge 0x9/","content":"jadx打开分析，这个本地方法check_flag返回值为1337的时候会自解密 这里直接hook掉check_flag的返回值，这里不知道是为什么直接当静态方法就可以hook，并且用frida搜so文件的时候是搜不到这个liba0x9的导致参考答案给的脚本一直跑不出来。直接对java层进行hook，frida会帮我们识别分析，这样也更方便快捷 function main() Java.perform(function() var a= Java.use(com.ad2001.a0x9.MainActivity) a.check_flag.implementation=function() console.log(hooked) return 1337 )setImmediate(main) 注入得到结果","categories":["android-reserve/frida/实战"]},{"title":"Challenge 0x8","path":"/2025/09/23/android-reserve/frida/实战/Challenge 0x8/","content":"jadx打开 很明显我们要hook的是内部字段res，去分析本地文件肯定很麻烦，这里返回值是这个cmpstr本地方法返回值是1就是right,可以猜测本地方法里最后一步是比对字段，所以可以直接hook相关方法，ida打开so文件查看导入函数有strcmp，可以直接hook这个函数 strcmp是来自libc.so文件中，ida中也可以看出来 function main() Java.perform(function() var strcmp_adr=Module.findExportByName(libc.so,strcmp) Interceptor.attach(strcmp_adr, onEnter:function(args) var arg0=Memory.readUtf8String(args[0]) var flag=Memory.readUtf8String(args[1]) if(arg0.includes(Hello)) console.log(input +arg0) console.log(The flag is +flag) , onLeave:function(retval) ) )setImmediate(main) 注入输入”Hello”就可以hook到strcmp比对的前两个参数，一个是我们的输入一个是flag","categories":["android-reserve/frida/实战"]},{"title":"Challenge 0x7","path":"/2025/09/23/android-reserve/frida/实战/Challenge 0x7/","content":"jadx打开，很清晰，要去hook一个构造方法 frida一把梭 function main() Java.perform(function() Java.choose(com.ad2001.frida0x7.MainActivity, onMatch:function(instance) var a =Java.use(com.ad2001.frida0x7.Checker) var ch = a.$new(530,532) instance.flag(ch) , onComplete:function() ) )setImmediate(main) 注入得到结果","categories":["android-reserve/frida/实战"]},{"title":"Challenge 0x6","path":"/2025/09/23/android-reserve/frida/实战/Challenge 0x6/","content":"jadx分析一下，就是Checker 的两个成员变量为1234 和4321时自解密 Checker再这，所以还得new一个出来 直接hook,这里如果Checker的实例a在choose的外面是不会生效的，这和java的懒加载机制有关，如果创建Checker实例的代码写在choose外面，这时可能还没有加载MainActivity，就不会触发onMatch中的代码也就不会hook成功 function main() Java.perform(function() Java.choose(com.ad2001.frida0x6.MainActivity, onMatch:function(instance) var Checker=Java.use(com.ad2001.frida0x6.Checker) var a =Checker.$new() a.num1.value=1234 a.num2.value=4321 instance.get_flag(a) , onComplete:function() ) )setImmediate(main) 注入得到结果","categories":["android-reserve/frida/实战"]},{"title":"Challenge 0x5","path":"/2025/09/23/android-reserve/frida/实战/Challenge 0x5/","content":"jadx分析一下，就是flag方法传入1337时就会自解密 主动调用一下，这是个非静态方法，和静态方法的主动调用不一样 function main() var ret=null Java.perform(function() Java.choose(com.ad2001.frida0x5.MainActivity, onMatch:function(instance) instance.flag(1337) , onComplete:function() console.log(ret) ) ) returnsetImmediate(main) 注入得到结果","categories":["android-reserve/frida/实战"]},{"title":"Challenge 0x4","path":"/2025/09/23/android-reserve/frida/实战/Challenge 0x4/","content":"jadx分析，MainActivity里面什么都没有 关键逻辑在Check里面 直接主动调用就可以了,这里要注意的就是此时进程中是没有这个Check实例的，只启动了MainActivity，所以得自己new一个实例出来再去调用get_flag方法 function main() Java.perform(function() var a =Java.use(com.ad2001.frida0x4.Check) var check=a.$new()//创建实例 var res =check.get_flag(1337) console.log(res) )setImmediate(main) frida注入得到结果","categories":["android-reserve/frida/实战"]},{"title":"Challenge 0x3","path":"/2025/09/23/android-reserve/frida/实战/Challenge 0x3/","content":"扔进jadx，就是一个Checker.code等于512的时候会自解密输出 而checker内部是这样，点5122256次之后就会自解密了 可以直接hook修改code的值 function main() Java.perform(function() var a =Java.use(com.ad2001.frida0x3.Checker) a.code.value=512 console.log(a.code.value) )setImmediate(main) 启动注入得到结果","categories":["android-reserve/frida/实战"]},{"title":"Challenge 0x2","path":"/2025/09/23/android-reserve/frida/实战/Challenge 0x2/","content":"用jdax反编译一下，没有任何输入，它内部自己完成了一个解密 那么直接主动调用这个get_flag函数就好了 也可以用objection","categories":["android-reserve/frida/实战"]},{"title":"Challenge 0x1","path":"/2025/09/23/android-reserve/frida/实战/Challenge 0x1/","content":"打开看看，是输入一个number然后验证 jadx反编译一下，逻辑很简单，但是这里用了随机数，没有设置seed，所以每次得到的随机数是未知的在1-100之间，这里爆破也是可以的 由于是为了练习frida，所以这里用frida进行内存漫游hook到每次启动得到的随机数，只需要hook到随机数i再计算出2*i+4就是我们输入的数 function main() Java.perform(function() var a =Java.use(com.ad2001.frida0x1.MainActivity); a.get_random.implementation=function() console.log(hooked); let ret =this.get_random(); console.log(value is +ret); return ret; )setImmediate(main); 注入拿到随机数25,25*2+454 输入54，得到结果 还可以直接hook重写get_random，让它返回固定结果 function main() Java.perform(function() var a =Java.use(com.ad2001.frida0x1.MainActivity) a.get_random.implementation=function() console.log(hooked) let ret=this.get_random() console.log(ret) return 5 )setImmediate(main) 这里hook返回的随机数是78，但是我输入的是14还是给出答案了 第三种直接hook check方法，这样不论输入什么都是相等的 function main() Java.perform(function() var a = Java.use(com.ad2001.frida0x1.MainActivity) a.check.implementation=function(i,i2) console.log(hooked) this.check(i,2*i+4) return; )setImmediate(main) frida启动输入","categories":["android-reserve/frida/实战"]},{"path":"/2025/09/23/android-reserve/android/JNI接口/","content":"JNI简介 JNI(java native interface),用于java代码调用c/c++代码，跳出虚拟机之外和c/c++代码进行交互。可以提高程序性能，同样也可以提防逆向。 JNI的优点： （1）JNI使得一些”过程”无需在Java中实现。例如，硬件敏感的，或者直接与操作系统API关联的命令。 （2）由于使用底层的库，如图形，计算，各种类型的渲染等等，可以提高应用的运行性能。 （3）已经有大量的库已经被实现，编程者可直接使用，不用再自行编写。这里的库指的是用其他编程语言实现的程序库，例如IO流或者线程等底层与OS交互的操作都是由CC++实现的。 JNI静态注册 静态注册就是在java代码编译完成后注册的。静态注册通常在编译时完成，即在Java代码中通过System.loadLibrary方法加载JNI库时，会根据库中的函数名查找对应的JNI函数。如果找到了，会在native函数与JNI函数之间建立关联关系，保存JNI函数的函数指针。所以静态注册c/c++中的函数名一定是 Java + 包名 + 类名 + 方法名 在java层写好如下代码 public class HelloJNI static System.loadLibrary(hello); private native void sayHello(); public static void main(String[] args) new HelloJNI().sayHello(); 然后编译以上代码生成一个Java类 HelloJNI.java文件 javac HelloJNI.java 再利用类文件生成一个编写cc++的头文件 javah HelloJNI 执行上面命令后生成类似stdio.h的一个HelloJNI.h文件。 /* DO NOT EDIT THIS FILE - it is machine generated */#include jni.h/* Header for class HelloJNI */#ifndef _Included_HelloJNI#define _Included_HelloJNI#ifdef __cplusplusextern C #endif/* * Class: HelloJNI * Method: sayHello * Signature: ()V */JNIEXPORT void JNICALL Java_HelloJNI_sayHello(JNIEnv *, jobject);#ifdef __cplusplus#endif#endif 然后才可以在c语言里面实现 #include jni.h#include stdio.h#include HelloJNI.hJNIEXPORT void JNICALL Java_HelloJNI_sayHello(JNIEnv *env, jobject thisObj) printf(Hello World! ); return; 再编写两个.mk文件，android.mk和application.mk文件并放到jni目录 再到JNI文件所在路径执行以下命令 NDK-build 就可以生成.so文件 JNI动态注册 动态注册是在java运行过程中注册的。通过提供一个函数映射表，注册给JVM虚拟机。这种方式不需要在编译时确定所有的native函数和对应的JNI函数，而是在需要调用native函数时，通过JNI库中的`RegisterNatives()`函数将映射表注册给JVM。所以在动态注册时c/c++中的函数名是自定义的。 先在java层写好代码 package com.example;public class MyJNI public native void myNativeMethod(); static System.loadLibrary(hello); 同样是和静态注册一样编译再利用javah生成.h头文件 #ifndef _Included_com_example_MyJNI#define _Included_com_example_MyJNI#ifdef __cplusplusextern C #endifJNIEXPORT void JNICALL Java_com_example_MyJNI_myNativeMethod (JNIEnv *, jobject);#ifdef __cplusplus#endif#endif 然后在cc++中实现JNI_onload，就完成了动态注册 #include jni.h#include com_example_MyJNI.hextern C JNIEXPORT void JNICALL Java_com_example_MyJNI_myNativeMethod(JNIEnv *env, jobject obj) // 本地方法实现static const JNINativeMethod gMethods[]= myNativeMethod,()V,(void*)Java_com_example_MyJNI_myNativeMethod)//建立映射关系，第一个参数是java层方法名，第二个参数JNI函数签名，是第三个是c/c++层函数名//关于函数签名（）V//()内部是说明函数接收参数情况，v说明返回值类型,这里就是返回void//这些签名的标识符和java数据类型的标识符一致 jint JNI_OnLoad(JavaVM *vm, void *reserved) JNIEnv *env; if (vm-GetEnv((void **)env, JNI_VERSION_1_6)!= JNI_OK) return -1;//调用javaVM的函数来分析是否动态注册成功，如果返回-1则注册失败 jclass clazz = env-FindClass(com/example/MyJNI); if (clazz == nullptr) return -1;//获取要动态注册的jclass对象，返回-1则注册失败 return JNI_VERSION_1_6;//动态注册实现 最后同样使用NDK-build生成.so文件 JNI常用方法 jmethod Getobjectmethodid(jclass clazz,const char* name,char*siq) 该方法用于获取方法id 参数 jclass class:Java类 name:方法名 siq:方法标识，就是方法返回值的类型 (*callobjectMethod)(JNIEnv*env,jobject,jmethod,...) 该方法用于调用一个java方法并以object类型返回 参数 JNIEnv*env : JNI接口指针 jobject : 指定方法的对象 jmethod : 方法的id 最后一个参数是调用方法的列表信息 const char*GetStringUTFChars(JNIEnv*env,jstring string,jboolean*isCopy) 用于c中读取java字符串（格式是UTF-8的字符串，函数名中没有UTF字符串格式就是Unicode） 参数 JNIEnv*env : JNI接口指针 jstring string : 从java中得到的字符串 isCopy :这也是一个默认参数，如果你调用该函数得到的是原字符串的一份拷贝，那么该指针指向的内存地址会被设置成为JNI_TRUE即isCopyJNI_TRUE。而如果你调用完函数，你得到的是指向原字符串的指针，该参数会指向JNI_FALSE。 jstring NewString(JNIEnv*env,const jchar*unicodeChars,jsize len) 用于构造新的java字符串 参数：JNIEnv*env:JNI接口指针 unicodeChars:指向Unicode字符串的指针 len:Unicode字符串的长度 jclass FindClass(JNIEnv*env,const char*name) 用于搜索加载本地定义类。返回类名，没找到返null。 参数: JNIEnv*env: JNI接口指针 name ：类全名 jfieldID (*GetobjectFieldID)(JNIEnv*env,jclass,const char*,const char *)ex:jfieldID fid=(*env)-GetFieldID(env, jcls, firstName, Ljava/lang/String;); 用于获取实例对象id 参数: JNIEnv*env: JNI接口指针 jclass: 类名 第一个参数const char*是字段名 第二个参数const char*是字段描述符 jobject *GetobjectField(JNIEnv*env,jobject,jfieldID) 用于获取实例对象 参数: JNIEnv*env: JNI接口指针 jobject: 对象名 jfieldID:对象ID void Setobjectfield(JNIEnv*env,jobject,jfieldID,jobject) 用于设置java实例字段的值 参数: JNIEnv*env: JNI接口指针 jobject:对象名 jfieldID:实例id值 jobject:该字段实际的值"},{"title":"frida-dexdump","path":"/2025/09/23/android-reserve/frida/理论/frida-dexdump/","content":"这个脱壳原理是动态注入之后扫内存，把疑似.dex文件结构（根据魔术头特征）的地址块都dump出来。 用frida-dexdump脱出来的checksum和sha1值可能会不对，这会导致jadx无法成功反编译，如图，是看不了源代码的 这个时候要用010手动改校验值，才能正常反编译（用JEB没有这个问题），010都会自动计算出正确的checksum和sha1值，根据改过来就可以了 改过的是可以直接进行反编译的","categories":["android-reserve/frida/理论"]},{"title":"绕过检测","path":"/2025/09/23/android-reserve/frida/理论/绕过检测/","content":"对frida的检测主要就是通过几个frida特征点检测 检测map /proc/进程id/maps这个文件包含了当前进程的内存映射信息 adb shell ps | findstr com.ad2001.frida0x8 这个命令是查找包含”com.ad2001.frida0x8”的进程信息，ps是列出正在运行的进程 运行结果第一个是用户id，第二个是进程id，第三个是父进程id，后面两个跟依次是虚拟内存、共享内存，再后面的可以先不予考虑 再用 cat proc进程idmaps | grep frida 可以查到相关frida特征，图中的frida-agent-64.so就是frida的显著特征 检测maps就是通过来检查这里的frida特征来检测frida 它的检测脚本大致长这样，一般情况都是在so里面 bool check_maps() // 定义一个足够大的字符数组line，用于存储读取的行 char line[512]; // 打开当前进程的内存映射文件/proc/self/maps进行读取 FILE* fp = fopen(/proc/self/maps, r); if (fp) // 如果文件成功打开，循环读取每一行 while (fgets(line, sizeof(line), fp)) // 使用strstr函数检查当前行是否包含frida字符串 if (strstr(line, frida) || strstr(line, gadget)) // 如果找到了frida，关闭文件并返回true，表示检测到了恶意库 fclose(fp); return true; // Evil library is loaded. // 遍历完文件后，关闭文件 fclose(fp); else // 如果无法打开文件，记录错误。这可能意味着系统状态异常 // 注意：这里的代码没有处理错误，只是注释说明了可能的情况 // 如果没有在内存映射文件中找到frida，返回false，表示没有检测到恶意库 return false; // No evil library detected. 绕过也容易，直接hook掉libc.so里面的strstr函数就可以了 function anti_maps() // 查找libc.so库中strstr函数的地址，strstr用于查找字符串中首次出现指定字符序列的位置 var pt_strstr = Module.findExportByName(libc.so, strstr); // 查找libc.so库中strcmp函数的地址，strcmp用于比较两个字符串 var pt_strcmp = Module.findExportByName(libc.so, strcmp); // 使用Interceptor模块附加到strstr函数上，拦截并修改其行为 Interceptor.attach(pt_strstr, // 在strstr函数调用前执行的回调 onEnter: function (args) // 读取strstr的第一个参数（源字符串）和第二个参数（要查找的子字符串） var str1 = args[0].readCString(); var str2 = args[1].readCString(); // 检查子字符串是否包含REJECT或frida，如果包含则设置hook标志为true if (str2.indexOf(REJECT) !== -1 || str2.indexOf(frida) !== -1) this.hook = true; , // 在strstr函数调用后执行的回调 onLeave: function (retval) // 如果之前设置了hook标志，则将strstr的结果替换为0（表示未找到），从而隐藏敏感信息 if (this.hook) retval.replace(0); ); // 对strcmp函数做类似的处理，防止通过字符串比较检测敏感信息 Interceptor.attach(pt_strcmp, onEnter: function (args) var str1 = args[0].readCString(); var str2 = args[1].readCString(); if (str2.indexOf(REJECT) !== -1 || str2.indexOf(frida) !== -1) this.hook = true; , onLeave: function (retval) if (this.hook) // strcmp返回值为0表示两个字符串相等，这里同样替换为0以避免匹配成功 retval.replace(0); ); 也可以重定向，定义一个伪造的maps路径 function mapsRedirect() // 定义伪造的maps文件路径 var FakeMaps = /data/data/com.zj.wuaipojie/maps; // 获取libc.so库中open函数的地址 const openPtr = Module.getExportByName(libc.so, open); // 根据地址创建一个新的NativeFunction对象，表示原生的open函数 const open = new NativeFunction(openPtr, int, [pointer, int]); // 查找并获取libc.so库中read函数的地址 var readPtr = Module.findExportByName(libc.so, read); // 创建新的NativeFunction对象表示原生的read函数 var read = new NativeFunction(readPtr, int, [int, pointer, int]); // 分配512字节的内存空间，用于临时存储从maps文件读取的内容 var MapsBuffer = Memory.alloc(512); // 创建一个伪造的maps文件，用于写入修改后的内容，模式为w（写入） var MapsFile = new File(FakeMaps, w); // 使用Interceptor替换原有的open函数，注入自定义逻辑 Interceptor.replace(openPtr, new NativeCallback(function(pathname, flag) // 调用原始的open函数，并获取文件描述符（FD） var FD = open(pathname, flag); // 读取并打印尝试打开的文件路径 var ch = pathname.readCString(); if (ch.indexOf(/proc/) = 0 ch.indexOf(maps) = 0) console.log(open : , pathname.readCString()); // 循环读取maps内容，并写入伪造的maps文件中，同时进行字符串替换以隐藏特定信息 while (parseInt(read(FD, MapsBuffer, 512)) !== 0) var MBuffer = MapsBuffer.readCString(); MBuffer = MBuffer.replaceAll(/data/local/tmp/re.frida.server/frida-agent-64.so, FakingMaps); MBuffer = MBuffer.replaceAll(re.frida.server, FakingMaps); MBuffer = MBuffer.replaceAll(frida-agent-64.so, FakingMaps); MBuffer = MBuffer.replaceAll(frida-agent-32.so, FakingMaps); MBuffer = MBuffer.replaceAll(frida, FakingMaps); MBuffer = MBuffer.replaceAll(/data/local/tmp, /data); // 将修改后的内容写入伪造的maps文件 MapsFile.write(MBuffer); // 为返回伪造maps文件的打开操作，分配UTF8编码的文件名字符串 var filename = Memory.allocUtf8String(FakeMaps); // 返回打开伪造maps文件的文件描述符 return open(filename, flag); // 如果不是目标maps文件，则直接返回原open调用的结果 return FD; , int, [pointer, int])); 检测status（线程名） 通过 ls /proc/进程id/task 列出线程id 再用 cat proc进程idtask线程idstatus 来查看每个线程的状态 这个检测也是通过特定的线程名来检测frida，例如以下这个就是frida注入后的特征线程gdbus gmain：Frida 使用 Glib 库，其中的主事件循环被称为 GMainLoop。 gdbus：GDBus 是 Glib 提供的一个用于 D-Bus 通信的库。 gum-js-loop：Gum 是 Frida 的运行时引擎，用于执行注入的 JavaScript 代码。 pool-frida：Frida 中的某些功能可能会使用线程池来处理任务，pool-frida 表示 Frida 中的线程池。 linjector 是一种用于 Android 设备的开源工具，它允许用户在运行时向 Android 应用程序注入动态链接库（DLL）文件。通过注入 DLL 文件，用户可以修改应用程序的行为、调试应用程序、监视函数调用等，这在逆向工程、安全研究和动态分析中是非常有用的。 以上这5个就是frida注入后会运行的几个特征线程 检测代码和maps一样也是通过strstr函数之类的来搜索比对线程名 绕过思路和上面一个差不多 function replace_str() var pt_strstr = Module.findExportByName(libc.so, strstr); var pt_strcmp = Module.findExportByName(libc.so, strcmp); Interceptor.attach(pt_strstr, onEnter: function (args) var str1 = args[0].readCString(); var str2 = args[1].readCString(); if (str2.indexOf(tmp) !== -1 || str2.indexOf(frida) !== -1 || str2.indexOf(gum-js-loop) !== -1 || str2.indexOf(gmain) !== -1 || str2.indexOf(gdbus) !== -1 || str2.indexOf(pool-frida) !== -1|| str2.indexOf(linjector) !== -1) //console.log(strcmp--, str1, str2); this.hook = true; , onLeave: function (retval) if (this.hook) retval.replace(0); ); Interceptor.attach(pt_strcmp, onEnter: function (args) var str1 = args[0].readCString(); var str2 = args[1].readCString(); if (str2.indexOf(tmp) !== -1 || str2.indexOf(frida) !== -1 || str2.indexOf(gum-js-loop) !== -1 || str2.indexOf(gmain) !== -1 || str2.indexOf(gdbus) !== -1 || str2.indexOf(pool-frida) !== -1|| str2.indexOf(linjector) !== -1) //console.log(strcmp--, str1, str2); this.hook = true; , onLeave: function (retval) if (this.hook) retval.replace(0); ) 检测linlinehook frida hook某个函数后会改变它的字节码，这个要检测也只能精准检测某些函数头地址 对抗的话，先获取hook前字节码 let bytes_count = 8 let address = Module.getExportByName(libc.so,open) let before = ptr(address) console.log() console.log([*] before hook: ) console.log(hexdump(before, offset: 0, length: bytes_count, header: true, ansi: true )); 再hook改回去就好了，这个应该用的不多 function hook_memcmp_addr() //hook反调试 var memcmp_addr = Module.findExportByName(libc.so, fread); if (memcmp_addr !== null) console.log(fread address: , memcmp_addr); Interceptor.attach(memcmp_addr, onEnter: function (args) this.buffer = args[0]; // 保存 buffer 参数 this.size = args[1]; // 保存 size 参数 this.count = args[2]; // 保存 count 参数 this.stream = args[3]; // 保存 FILE* 参数 , onLeave: function (retval) // 这里可以修改 buffer 的内容，假设我们知道何时 fread 被用于敏感操作 console.log(this.count.toInt32()); if (this.count.toInt32() == 8) // 模拟 fread 读取了预期数据，伪造返回值 Memory.writeByteArray(this.buffer, [0x50, 0x00, 0x00, 0x58, 0x00, 0x02, 0x1f, 0xd6]); retval.replace(8); // 填充前8字节 console.log(hexdump(this.buffer)); ); else console.log(Error: memcmp function not found in libc.so); 使用魔改的frida 魔改的frida会改掉一些原来的frida的特征，就可以绕过一些检测 https://github.com/hzzheyang/strongR-frida-android 注意：以上代码多来自于吾爱破解大佬正己，大佬的课非常好","categories":["android-reserve/frida/理论"]},{"title":"frida_fart","path":"/2025/09/23/android-reserve/frida/理论/frida_fart/","content":"工具版本 frida:16.1.0 MuMu模拟器 使用 需要先将js脚本中的savepath路径改为你要存储的地方，原文是com.kanxue.test， 可以改为datadata目标应用包名hook，这样还需要找到该路径创建一个hook文件夹 也可以把这行删了，把上面的注释符删掉，这样会存到sd卡里，需要sd卡的存储权限 开始使用，像正常frida脚本一样注入，这里获取的是几个疑似dex的地址 然后调用fart()函数完成脱壳 最后找到路径一个个排查，就可以得到脱壳后的代码","categories":["android-reserve/frida/理论"]},{"title":"app","path":"/2025/09/23/android-reserve/android/app/","content":"app种类 Web app(网页app) 采用Html5+JavaScript，不需要下载安装，依托于浏览器中的应用 Native App(原生app) 基于Google的SDK使用java和c/c++语言开发。 依托于操作系统的app Hybrid app(混合app) 半web半原生app，需要下载安装，Native框架但访问web内容。一般的新闻类app、视频类app都是属于混合app app运行 随着安卓系统的更新，app的运行模式也发生了变化 之前是Dalvik VM模式也就是和很多其它语言的程序一样的机器码形式，而新版本中的app运行模式是ART模式 Dalvik VM Dalvik VM是Google专门为移动设备优化的java虚拟机 特点： 专用的DEX可执行文件格式，体积更小，执行更快 所有的Android程序都运行在Android系统进程里，每个进程对应着一个Dalvik虚拟机实例 Dalvik 和 JVM（java虚拟机）不同： JVM运行的是java字节码，而Dalvik虚拟机运行的是Dalvik自己码 Dalvik可执行文件体积更小 JVM基于栈架构，Dalvik基于寄存器架构 exp: 基于栈架构： 所有操作数通过入栈出栈传递，指令仅仅关注栈顶元素。会导致出栈入栈频繁，内存开销大 基于寄存器架构： 指令中包含寄存器的编号，例如 ADD V0,V1,V2 表示V0V1+V2，直接对寄存器中的数据进行操作，寄存器由虚拟机进行管理。但是会导致指令比较长 ART 核心机制如下 AOT(预编译) 在应用安装的时候系统通过dex2oat将APK中的classes.dex转换为本地机器码（存储在/data/app/[包名]/oat/目录，存储格式为.oat文件），该编译过程会针对CPU架构进行优化，生成高效的本地指令 这样应用启动更快、运行更流畅，避免了Dalvik中即时编译的性能开销和电池消耗 垃圾回收优化 分代回收： 并发回收： 安全性 在预编译阶段强化对DEX文件的完整性校验 对编译后的本地代码施加内存保护（执行权和写入权分离） Intents Intents是一种运行绑定机制，能在程序运行过程中连接两个不同组件。例如startActivity(intent),startService(intent),sendBroadcast(intent)来掉起一个组件或者传递一些数据 分为显式和隐式两种 显式： 明确指定要启动的组件，用于应用内部组件跳转 Intent intent = new Intent(this, SecondActivity.class);startActivity(intent); 隐式：不直接指定具体要启动的组件，而是通过指定动作（Action）、类别（Category）、数据（Data）等信息，由系统根据这些信息匹配最合适的组件来处理的 Intent。用于跨应用通信 // 隐式Intent打开网页 Intent intent = new Intent(Intent.ACTION_VIEW, Uri.parse(https://www.example.com));startActivity(intent); app打包过程 Android应用打包的具体步骤如下： 1. 资源处理：使用AAPT或AAPT2工具将XML、图片等资源文件编译为二进制格式，生成R.java文件和resources.arsc资源映射表。同时，合并主模块与依赖库的AndroidManifest.xml文件，处理权限、组件声明等元数据。 2. 代码编译：使用Javac编译器将Java代码编译为.class字节码，使用Kotlin编译器将Kotlin代码编译为.class字节码。如果有AIDL（跨进程通信）接口，使用AIDL工具生成Java代理类。 3. 字节码转换：通过D8或DX工具将.class文件转换为Android专用的classes.dex文件。如果超过64K方法限制，启用Multidex拆分多个dex文件。 4. APK打包：使用apkbuilder或zipflinger等工具，将编译后的资源文件、dex文件、原生库（.so文件）等合并打包成一个未签名的APK文件。 5. APK签名：使用jarsigner或apksigner等工具，用开发者的签名文件对APK进行签名。签名方式有V1、V2、V3等，V2和V3签名在APK文件尾部插入签名块，增强防篡改能力。 6. 对齐优化：使用zipalign工具对APK文件进行对齐优化，调整资源偏移，提升运行时加载效率。","categories":["android-reserve/android"]},{"title":"android系统","path":"/2025/09/23/android-reserve/android/android系统/","content":"ROM ROM（read-only memory,只读存储器，‘只读’是出厂预存的系统文件属性为只可读）可以简单地理解为存储卡，手机的系统及其和核心组件都安装在ROM中，出厂时预装应用和用户后续安装的app、图片、视频、文档等也都在ROM的特点分区中 ROM划为多个逻辑分区 system系统分区，data用户分区，cache缓存分区 分区 /system :系统分区，存放系统核心文件和预装应用 data : 用户分区，存放用户数据、应用数据和个人文件，类似windows中的user（用户）文件 cache : 缓存分区，存放临时缓存和系统更新文件 dev (device): 设备文件，存放和硬件设备交互的接口，读取这些文件来控制硬件设备 特别的devbinder中存放的是IPC通信驱动接口，ActivityManagerService、PackageManagerService 等就是通过这个文件来发送和接收IPC请求，不同进程之间的通信也是通过这个接口来实现的 proc :虚拟文件系统，动态映射内核数据结构，例如进程、cpu、内存使用情况等信息 驱动 驱动的核心作用是充当操作系统和硬件设备（显卡、键盘、打印机、摄像头等）之间的'翻译官'，将电子信号翻译成数字信号。 启动流程 Boot Loader加载 boot loader是按下电源后第一个加载的。这个阶段都会运行一些制造商自定义的初始化代码 加载kernel Boot 分区加载kernel（内核）与initrd到RAM（随机存储器，也就是运行内存），最后跳转到kernel继续完成启动 kernel(内核) kernel是操作系统的核心组件，负责管理硬件资源和为上层程序提供接口 管理硬件资源 决定让哪个进程获得CPU的运行时间， 分配和回收内存空间， 通过驱动程序与硬件设备通信，控制设备的读写、启动、关闭等操作 管理磁盘上的文件和目录，负责文件创建、删除、读写、已经权限控制 处理网络数据的发送和接收 给上层程序提供系统调用接口（System call） 上层程序要用到什么，就通过这个接口调用什么，要保存文件的时候就通过内核的\"写文件\"系统调用 总的来说，上层程序看在这里看上去像是人的思维，表明要干什么，而内核则是想是心脏，得到指令，开始驱动四肢（硬件设备)运动 初始化设备服务 内核kernel会启动所有Android 系统设备所必须的服务，初始化Memory(存储器)、初始化IO、内存保护、驱动、cpu调度等，还会挂载文件系统 加载系统服务 初始化设备服务后，会启动init进程，进程PID为1，父进程是PID为0的 Kernel,它会执行init.rc的脚本中的代码，会初始化android系统的核心服务例如针对通话的rild、针对VPN连接接的mtpd等等 init.rc 这个文件是用android自定义的初始化语言写的 虚拟机初始化 init还会初始化一个Zygote进程，这个进程会创建Dalvik VM，会启动第一个java组件系统服务和Android Framework服务 启动完成 当系统完全启动之后，载入Home(桌面应用程序)，然后做一些应用层的初始化工作 Zygote Zygote(受精卵)这是init初始化启动的一个进程。它启动之后会： 加载android框架、资源文件和系统共享库 初始化虚拟机，预编译部分字节码 启动ZygoteServer,监听来自系统服务的进程创建请求（通过socket通信），此时Zygote处于“待命状态”，等待创建新进程的指令 总的来说，这个进程是给app提供框架、库和服务的。 例： home(桌面应用程序)的启动 系统完成启动完成后,ActivityManagerService（AMS，系统服务之一）会检测并启动home AMS会通过Process.start()向ZygoteProcess发送请求，告知要创建一个进程来运行桌面应用的包名（如com.android.launcher3） zygote接收到ZygoteProcess（通过socket）的请求后会fork一个和zygote一样的子进程 新fork的子进程会由ActivityThread初始化来脱离Zygote。 而桌面的普通app，是由桌面应用通过Intent向AMS发送请求 app运行中新fork子进程的初始化包括： 启动应用专属主线程ActivityThread 绑定Application对象，创建上下文（context） 加载目标app的apk文件、dex代码和私有资源 匿名共享内存机制 Ashmem为用户空间程序提供分配内存的机制。它为多个进程提供共享的内存空间，并完成该共享内存的回收和释放。 就是进程A在内存中申请一块共享内存，然后将运行中产生的数据写入内存并设置访问内存保护权限和标文件描述符（例如fd），然后通过Binder(跨进程通信)把fd传给进程B，B就可以访问该共享内存了。 这个机制用于传输大型的文件。这样只用传一个文件描述符，效率极高 日志 android保存了linux的日志机制，还使用了另一套日志系统——Logger，该驱动用于支持Logcat命令，用于查看4个独立的日志缓冲区 devlogmain(主缓冲区)，用于记录应用相关事件来源 devlogradio(广播缓冲区) devlogevent(事件缓冲区） devlogsystem(系统缓冲区) apk安装 签名： 安装apk时，安装应用程序会通过CERT.RSA查找公钥和算法，并对CERT.SF进行解密和签名验证，确认MANIFEST.MF，最终对每个文件签名校验 安装过程： 会复制apk安装包到/data/app目录下，解压并扫描安装包，把dex文件保存在dalvik-cache目录，并在/data/data目录下创建应用数据目录 静默安装 应用正常安装时向packageinstaller发送一个intent进行安装，然后packageinstaller会弹出如下一个安装授权界面 静默安装就是绕过这个权限授予在不需要用户同意的情况下安装 packageinstaller是通过PackManagerServer（PMS系统服务）中的installPackage方法进行安装的，这是一个抽象且对外不可见的方法。 而root权限下的pm命令可以直接调用这个隐藏方法进行安装来达到静默安装的效果，且可以安装到systemapp下，让用户难以察觉 还可以修改init.rc中的脚本内容实现静默安装。这种静默安装会在每次系统重启的时候都重新安装一遍。 删除预装： 删除/system/app中对应的.apk和.odex(优化过的dex文件)就可以删除预装软件 android层级与安全措施 应用层：接入权限、代码保护 框架层：数字证书 Dalvik: 沙箱机制 内核层：Linux Android权限 android中的权限中有两个重要标识UID和GID UID（用户ID）: 这个是Android中的沙箱隔离机制，每个应用在安装时都会被系统分配一个唯一的UID，不同UID的应用是不能相互访问各自的资源、内存等 GID（组ID）：一个应用可以有多个权限，如，同时拥有CAMERA和INTERNET权限，就会同时拥有camera组的ID和internet组的ID root权限原理 root权限就是将uid和gid设置为0，root用户 已经获取Root后的系统比没有Root的系统多了”su”和”SuperUser.apk”, su的源码在systemextrassu下，这个是用来获取root权限的程序，SuperUser.apk是用来管理root权限的应用 获取root思路就是 将编译好的su程序放入系统环境systembinsu 将su文件所有者和所属组设置为root，避免权限混乱（使用命令 chown root:root systembinsu） 将su文件的权限改为”-rwsr-sr-x”(命令 chmod 6755 systembinsu) 安装SuperUser.apk 但是完成以上操作都是要root权限的，只能通过漏洞来实现 SuperUser.apk就是一个用来管理root权限（设置白名单）和验证su文件的应用，市面上很多开源的文件，也可以通过攻击该应用获取root权限 RageAgainstTheCage漏洞 原理：android的init进程启动adbd后，adbd会在运行一段代码后进行降级（init进程是root权限，adbd作为其子进程也是root权限）但是adbd中的代码没有对降级失败后的处理，仍然继续运行。而adbd是什么权限，adb就是什么权限。如此让降级代码执行失败就可以获取root权限了 步骤： 出厂设置ro.secure属性为1，adbd会读取它的属性,如果为1就会降级为shell权限 adb工具创建的进程ratc也运行在shell用户权限下,用ratc一直创建子进程，直到达到该用户最大可创建进程数（RLIMIT_NPROC）时，后续创建进程失败 此时手动杀死adbd进程，因为这是系统服务，android系统会自动重启 新启动的adbd仍以root权限运行，随后执行降级代码 在adbd运行时,ratc仍在持续尝试创建子进程，导致进程数已到配额数，这时候adbd会执行降级代码失败，仍以root权限运行下去 信号监控 按键信号 用户点击物理按键或者软按键（手机里浮在屏幕上的按键），键盘的输入驱动就会产生一个中断，并向/dev/input/eventX(X为设备编号，对应着触摸屏、音量键和电源键等设备)中写入一个相应的信号，android操作系统会循环读取之中的事件再分发给WindowsManagerServer,由WindowsManagerServer根据事件来源分发到不同的ViewGroup和View中，产生不同的OnClick、OnKeyDown和OnTouch等事件 getevent命令可以获取信号，添加 -l 加入标签 例：如果按了软键盘上的某个键，会获得如下信息，虽然我们知道按的”1”但是列出来的信息只给了触摸到的x,y坐标，可以通过监听这里再根据屏幕大小推出是按了什么键 这种情况会有这种乱序的软键盘来对抗 但如果是按的物理键盘会直接告诉按了什么键 短信 短信是一种广播，而广播分为有序广播和普通广播 普通广播是完全异步的，任何接收者都可以接收到 而有序广播会优先发送给优先级最高的receiver 短信拦截：短信是一种有序广播，所以可以声明一个优先级非常高的receiver来拦截短信 短信静默发送：即不通过用户同意后台静默发送短信，通过系统的SmsManager中的sendTextMessage方法来发送 电话 电话拨打 android上的TelephonyManager中的方法是针对设备通话的封装，其API是不对系统外的应用开放的(注解为@Systemapi方法)。但是可以通过java的反射机制来调用其接口，只需要在AndroidManifest.xml中声明CALL_PHONE权限然后调用TelephonyManager中的call方法就可以不经过用户同意就打电话 电话监听 只需要在TelephonyManager中注册PhoneStateListener就可以拿到当前通话状态的变化，就可以做出相应的处理 dex dex文件是由JVM编译过后再由Dalvik编译后生成的 dex文件结构由header,table,data组成 header：和正常的文件头一样，用来声明文件格式、大小等信息 table：用来声明一些结构化数据引用数据以及数据偏移量 data：放的是具体逻辑和数据 屏幕锁 android的屏幕锁，不论是图形锁还是密码锁，都会将密码进行加密后存储在/data/system/gesture.key中，通常是用LockSettingsService将密码进行SHA1加密存放到文件中。直接删掉，系统会认为手机没有设置屏幕代码 系统调用机制 linux基于ARM架构的系统 通过软件中断（SWI）从用户态进入内核态 再由中断处理程序进入系统调用表 由系统调用表找到系统调用函数 所以这里有个攻击点 可以对系统调用表进行重定向，重定向到一个自定义的表地址里 可以对系统调用表里的指针进行重定向，重定向到恶意函数地址 可以搜索sys_call_table(系统调用表)找到 LKM(Loadable Kernel Modules) LKM是linux可加载的内核模块。实际上为.ko后缀文件（旧版本为.elf） linux内核采用单核机制，内部分为若干功能模块，模块间通信通过直接调用其它模块或系统1提供的内核函数来实现。但是这样任何功能的添加和删除都要重新编译内核，这就引入了LKM LKM包含module_init和module_exit宏，用来声明注册函数和卸载函数。向内核插入模块就调用module_init注册的函数，卸载就调用module_exit注册的一个或多个函数 LKM加载分为静态和动态两种方式 静态直接将代码编译进内核 动态使用shell命令 insmod或modprob加载 通过rmmod或modprob卸载 Rootkit Rootkit是一类恶意软件。旨在获取root权限并长期潜伏，同时隐藏自身以及相关恶意活动，逃避检测与清除。它是一套技术组合，并非单一工具 环境搭建 1. 准备Android SDK、Android NDK、Git 、JDK等工具 2. 下载对应设备的内核源码 3. 添加环境变量 4. 配置config 5. 编译 自定义内核程序 1. 编写驱动代码：在drivers目录下新建一个文件夹，例如hello，在hello目录下，新建三个文件夹hello.c（源码）、Kconfig（配置文件）、Makefile 2. 添加配置文件：为了让模块能在配置选项中出现，需要在/arch/arm/Kconfig(这个是内核编译前出现大的文件)文件中的menu \"Device Drivers\" 和endmenu直接添加 source \"drivers/hello/Kconfig\"。在drivers/Kconfig文件中实现同样操作 3. 修改Makefile:将hello模块的编译信息添加到Makefile中参与驱动的编译，添加 obj -$(CONFIG_HELLO) + hello 这里的CONFIG_HELLO存在三种情况yn（参与不参与编译）,m（动态载入模块） 使用make menuconfig命令更改编译选项 编译 隐藏 1. 屏蔽lsmod（这个命令可以打印出来当前加载的索引LKM）：lsmod命令是通过/proc/modules来获取当前模块信息。而/proc/module是内核利用struct modules结构体的表头遍历内核模块链表来的到模块信息，只需要删除相关链表就可以屏蔽lsmod 2. 文件隐藏：屏蔽掉ls ll等命令检测,通过修改调用表的方式替换系统函数，过滤掉不希望显示的文件 3. 网络连接隐藏：网络连接信息会保存在/proc/net目录下的tcp和udp文件下，所以查询网络连接也是通过这两个文件查询，修改调用表过滤掉查询信息 检测 1. 文件完整性检测：检测系统中重要的文件的MD5值 2. Rootkit特征库检测：根据已知Rootkit工具库中的特征字符串作为“指纹”，建立指纹数据库进行检索 3. 可执行路径检测：如果篡改了内核函数，那么调用该函数时系统的执行流程会发生变化。启用处理器的单步执行模式、测定系统分析执行路径（每个内核函数的路径不一样）来检测 已有的检测模型 proccheckmod提供了一个检测模型的接口，通过命令来检测 备份系统调用表等相关信息，每次系统调用前进行比对 也可以通过LKM来检测","categories":["android-reserve/android"]},{"title":"apk的四大组件","path":"/2025/09/23/android-reserve/android/apk的四大组件/","content":"Activity 用于表现功能，每个界面就是一个activity。 相关方法 1.onCreate()创造的时候会调用 2.onStart()活动由不可见变为可见的时候调用 3.onResume()准备和用户交互的时候调用 4.onStop()活动变为不可见的时候调用 5.onPause()活动停用的时候调用，就是当前页面弹出一个小窗时候调用，此时操作不了当前activity 6.onDestroy()销毁活动前调用，释放空间，清出栈 7.onRestart()活动由pause变为可运行时调用 生命周期 1.完整生存期：从create到destroy 2.可见生存期：从start到stop 管理模式 1.standard:模式android采用多个Task管理多个activity,每启动一个app，android就会创造一个Task,然后每启动一个activity,就把当前的activity压入栈顶。 2.singleTop模式：这个模式下启动的activity作栈顶的时候可以被复用，就是可以从界面a-界面b-界面b。这里栈顶b就被复用了 四种activity activity都是通过Intent启动的 私有activity:只能通过本应用程序启动 伙伴activity:只能通过特定声明的程序启动 公共activity:任意启动的 内部activity:嵌套在activity内部的和内部类类似 Service 服务是一个后台运行的组件，执行长时间运行且不需要用户交互的任务。听歌的时候把界面放后台了，歌仍然在放，此时就是一个service在运行。 分类 service也是通过Intent来启动的，也是分为私有、公共、合作、内部，和activtity类似 状态 1.Started:普通运行模式，普通生命周期，从onCreate、onStarted到no callback后onDestroy 2.Bound:绑定，与多个客户服务接口相连提供服务（cs通信模式）,和常用的vx通信机制一样，你用vx时发消息给服务器，服务器再发给你想要发的人。生命周期onCreate、onbind、onunbind、onDestroy。 Broadcast receiver 广播接收器用于响应来自其他应用程序或者系统的广播消息。这些消息有时被称为事件或者意图。 很多广播都是来源于系统代码。例如，开机广播、电池电量低广播、拍摄和改变语言选项广播等 广播有两种注册方式 静态注册：AndroidManifest.xml中声明 动态注册：Java代码中动态声明 分类 广播接收器(Brocast Receiver)分为三种私有、公共、内部。区别和activity的分类相似 广播从定义上分为两类： 静态广播：在AndroidMainfest.xml中注册，应用不启动也能接收广播，依赖系统预注册，优先级较低 动态广播：在代码中通过registerReceiver注册，与注册的组件（activtity,service）绑定，可动态注册解绑，优先级较高 Content provider 内容提供者组件通过请求从一个应用程序向其他的应用程序提供数据。这个仅仅是一个数据共享接口。 分类 也是分为私有、公共、合作、内部，区别和activity类似。但是还有一种部分content provider，它基本上是私有类型，但允许特定的应用通过特定的URI（这里的URI是访问路径）来访问 四大组件之间的关系","categories":["android-reserve/android"]},{"title":"apk的.xml声明","path":"/2025/09/23/android-reserve/android/apk的.xml声明/","content":"全部都是.xml文件里面的部分 user-permission这个看名字也能知道，是权限，用来声明这个app的权限信息。 queries元素是AndroidManifest.xml文件中的一个组件，用于在Android 11（API级别30）及更高版本中声明应用对其他应用的查询意图。通过添加queries元素，应用可以指定它想要与之交互的其他应用或组件，从而遵守系统的隐私保护策略 queries !-- 查询已安装的某个特定应用 -- package android:name=com.example.otherapp / !-- 查询能够处理特定意图的应用 -- intent action android:name=android.intent.action.VIEW /!--声明发起一个查看操作-- category android:name=android.intent.category.BROWSABLE/!--指定该意图需要与 可浏览的组件匹配。这意味着系统会查找能够处理浏览相关操作的应用。-- data android:scheme=https /!--指定数据的协议为 https-- /intent!--这个意图表示应用想要查询能够处理 https 协议网页浏览的应用-- intent action android:name=android.support.customtabs.action.CustomTabsService/ /intent!--该意图用于查询支持自定义标签服务（Custom Tabs Service）的应用--/queries intent-filter：这个元素就是系统地告诉你这个组件能做什么。 活动别名，它是具体指向一个活动的，利用这个可以很容易的修改活动的图标、标签之类的信息。 activity android:name=icu.nullptr.hidemyapplist.ui.activity.MainActivity android:exported=true android:windowSoftInputMode=adjustPan intent-filter action android:name=android.intent.action.MAIN/ category android:name=de.robv.android.xposed.category.MODULE_SETTINGS/ /intent-filter /activity activity-alias android:label=@string/app_name android:name=com.tsng.dyhhvf.MainActivityLauncher android:exported=true android:targetActivity=icu.nullptr.hidemyapplist.ui.activity.MainActivity intent-filter action android:name=android.intent.action.MAIN/ category android:name=android.intent.category.LAUNCHER/ /intent-filter /activity-alias mate-data:用来声明元数据。 activity android:name=.MainActivity meta-data android:name=com.example.app.MY_METADATA android:value=Hello, Metadata! //activity 在java中使用方法 String metaDataValue = activityInfo.metaData.getString(com.example.app.MY_METADATA);//这里metaDataValue的值为Hello,Metadata!","categories":["android-reserve/android"]},{"title":"hook","path":"/2025/09/23/android-reserve/hook/","content":"hook本质上是改变了函数名指向，将原来要执行的函数指向了我们定义的函数 hook原理 前言：内核捕获系统调用 linux中，用户态程序发起系统调用的流程是固定的 用户态程序执行syscall指令（x86_64）或int 0x80(x86)来主动陷入内核态并将系统调用要用到的参数存入指定寄存器 然后要执行哪个系统调用是由寄存器rax中的系统调用号来决定的 所以hook的时候可以让目标进程在进入系统调用的时候暂停，然后用ptrace来修改目标进程的寄存器的值来主动调用系统函数 android内核中有个函数叫ptrace，它能够attach(跟踪进程)、detach(结束跟踪)、 peektext(获取内存字节)、poketext(向内存写入地址)等 还有个内核函数dlopen，能够以指定模式打开指定动态链接库，也可以利用它来注入动态库 hook流程为 用ptrace函数attach上目标进程。 ptrace函数定义: int ptrace(int request, int pid, int addr, int data ) 参数含义 request是ptrace执行的操作，例如PTRACE_ATTACH跟踪进程。pid是目标进程id，addr是目标进程地址，data是作用的数据 发现装载共享so函数。 通过ptrace（PTRACE_SYSCALL,..）让目标进程在进入或退出系统调用时暂停。例如，进入mmap或open时候暂停，获取其参数。再检查参数中是否包含.so文件名 exp:进程加载共享库的时候，动态链接器(linker或ld.so)会打开.so文件(open)、读取ELF文件头、映射到内存(mmap) 装载指定的.so。 通过ptrace向目标进程的内存中写入待注入的so路径（通过构造mmap来申请可读可写的内存，并获取该内存地址，再通过ptrace将路径写入该地址） 找到目标进程中dlopen的地址（通过解析proc[pid]maps找到动态连接器的内存映射范围，再从其符号表中获取dlopen的地址） 构造dlopen调用来注入so文件 exp:如果目标进程通过沙箱或者SElinux限制了dlopen，可以手动解析elf文件，然后用mmap在目标进程中安elf指定映射，手动重定位 让目标进程的执行流程跳转到注入的代码执行。 .so文件中的_init函数会被动态链接库主动调用完成初始化。 如果要在特定时机触发.so文件，可以通过ptrace来手动修改目标进程 使用ptrace函数的detach释放目标进程。 hook组件 针对activity，有些activity设置了访问权限，只能通过指定Intent来启动。要主动调用这些activity就要想办法hook到这些Intent。针对service也是这个思路。 针对Broadcast receiver则是构造一个优先级更高的广播接收器来截取广播 针对content provider 它可能有些权限问题没有声明规范导致越权访问。因为沙箱机制每个app的数据都放在datadata应用包名下，其它应用无权访问这些数据 代码中有对查询URI处理不当，可以构造URI来攻击 例如： 假设一个 ContentProvider 处理用户信息查询，设计的合法 URI 格式为：font style=color:rgba(0, 0, 0, 0.85);content://com.example.userprovider/users/123/font表示查询 ID 为 123 的用户数据，对应的 SQL 逻辑本应是：font style=color:rgba(0, 0, 0, 0.85);SELECT * FROM users WHERE id = 123/font 但是代码中直接提取URI不进行校验 @Overridepublic Cursor query(Uri uri, String[] projection, String selection, String[] selectionArgs, String sortOrder) // 错误：直接从URI中提取路径片段作为ID，未校验 String path = uri.getLastPathSegment(); // String sql = SELECT * FROM users WHERE id = + path; // 拼接SQL return db.rawQuery(sql, null); // 执行原始SQL 若UriMatcher未精确匹配路径格式（如允许模糊匹配或未限制路径长度），攻击者可构造如下恶意 URI：content://com.example.userprovider/users/123 OR 1=1 此时拼接后的 SQL 会变成：SELECT * FROM users WHERE id = 123 OR 1=1由于1=1恒为真，该语句会返回表中所有用户数据，导致全表泄露。 甚至可以恶意构造content://com.example.userprovider/users/123; DROP TABLE users;--若直接拼接 SQL，会执行：SELECT * FROM users WHERE id = 123; DROP TABLE users;--导致数据表被删除（虽然 ContentProvider 通常不开放删除权限，但仍存在风险）。 恶意构造来达到跨表来读取删除敏感信息等","categories":["android-reserve"]},{"title":"apk基本结构","path":"/2025/09/23/android-reserve/android/apk基本结构/","content":"Assets assets文件用来存放需要打包到android应用程序的静态资源文件。例如图片资源文件、JSON配置文件、二进制数据文件、HTML5离线资源文件等。这些不会产生资源id值。这些文件是不需要编译的。在代码中通过android官方API: AssetsManager来访问。以下是一个读取 assets目录下config.json 文件并解析其内容的实例,标蓝处为具体操作 import android.content.Intent;import android.content.res.AssetManager;import androidx.appcompat.app.AppCompatActivity;import android.os.Bundle;import java.io.BufferedReader;import java.io.IOException;import java.io.InputStream;import java.io.InputStreamReader;public class MainActivity extends AppCompatActivity @Override protected void onCreate(Bundle savedInstanceState) super.onCreate(savedInstanceState); setContentView(R.layout.activity_main); String json = readAssetFile(config.json); // 这里你可以根据需求解析 JSON 数据，比如使用 Gson 或 JSONObject System.out.println(json); private String readAssetFile(String fileName) StringBuilder stringBuilder = new StringBuilder(); AssetManager assetManager = getAssets(); try (InputStream inputStream = assetManager.open(fileName); BufferedReader reader = new BufferedReader(new InputStreamReader(inputStream))) String line; while ((line = reader.readLine()) != null) stringBuilder.append(line); catch (IOException e) e.printStackTrace(); return stringBuilder.toString(); Res 同样是存放资源文件，包括图片资源、字符串资源（修改这里的字符串资源可以达到汉化的目的）、颜色资源、尺寸资源等。这些资源是需要编译的，在编译后会生成一个R.java。以下是res目录下的目录的相关目录 animator：存放属性动画的XML文件 anim：存放补间动画的XML文件 drawable：存放各种位图文件，(.png，.jpg，.9png，.gif等)除此之外可能是一些其他的drawable类型的XML文件 mipmap-hdpi：存放应用图片的地方，后面pi是指分辨率 （minmap和drawable具体区别可以去看https://blog.csdn.net/wq6ylg08/article/details/114543624） layout：该目录下存放的就是我们的布局文件 color:存放颜色资源 interpolator:插值器，控制图片动画变化速率 res/raw 该目录存放原生资源(音频，视频，一些XML文件等），和assets下一样，访问通过API提供的方法访问，但是生成资源id值。 R.java： 这个属于一个java类，其中包含了所有res文件中资源的资源id值，访问这些资源是通过资源id值来访问的。 在java代码中像调用寻常类一样调用访问。 //获取文字getResources().getText(R.string.name);//获取string类型的res数据getResources().getString(R.string.name); //图片getDrawable(R.drawable.icon); //颜色getResouces().getColor(R.color.red); //布局setContentView(R.layout.main); //控件findViewById(R.id.txt_name) 在xml中直接@可以得到 TextViewandroid:text=@string/hello_world android:layout_width=wrap_content android:layout_height=wrap_content android:background=@drawable/img_back/ resources.arsc 资源映射表，包含了res目录下面所有资源及其资源id值 Lib 在 Android 中，lib 库是一组可以被应用程序调用的底层代码。它们通常是用 C 或 C++ 开发的，并通过接口JNI（Java Native Interface）与 Java 交互。Android 提供了多种内置的 lib 库，以支持不同的功能，例如音视频处理、图形操作等。 关于JNI接口可以去了解一下它的静态和动态注册https://blog.csdn.net/afei__/article/details/81031965 META-INF META-INF文件夹是存放数字签名相关文件的文件夹 MANIFEST.MF文件: 对apk中所有文件进行SHA1签名再转base64后生成的文件 CERT.SF: 用SHA1-RSA算法用私钥进行签名 CERT.RSA: 保存了公钥及所采用加密算法等信息 AndroidManifest.xml 这是android项目的系统清单文件，里面包含了程序中所有使用到的相关组件、各种权限和一些其他信息。 详解可以看https://www.cnblogs.com/shujk/p/14961572.html kotlin 编译产物存储 在 Android 开发中，如果使用 Kotlin 语言编写代码，Kotlin 编译器会把 `.kt` 文件编译成 Java 字节码（`.class` 文件），这些编译后的文件会被存储在 `kotlin` 文件夹里。主要包含以下几类： Kotlin 类文件：Kotlin 代码编译后生成的 font style=background-color:rgb(187,191,196);.class/font 文件会存于该文件夹，这些文件最终会被打包进 APK 里，以便在 Android 设备上运行。 Kotlin 标准库和依赖库：文件夹里也会包含 Kotlin 标准库以及项目依赖的其他 Kotlin 库的相关文件。这些库文件是 Kotlin 代码运行时所必需的，它们为 Kotlin 代码提供了基础的类和函数。 font style=background-color:rgb(187,191,196);kotlin/font 文件夹还会保存 Kotlin 代码的元数据，这些元数据对于 Kotlin 语言的一些特性来说是不可或缺的，比如： 元数据保存 + 反射：Kotlin 的反射功能依赖于这些元数据，它允许程序在运行时获取类、方法、属性等信息，从而实现动态调用和操作。 + 协程：Kotlin 的协程是一种轻量级的线程管理机制，其实现依赖于元数据来跟踪协程的状态和执行流程。 调试信息记录 在开发和调试阶段，`kotlin` 文件夹会包含调试所需的信息，例如： 源码映射：保存了编译后的字节码和原始 Kotlin 源码之间的映射关系。当使用调试工具（如 Android Studio 的调试器）时，开发人员可以通过这些映射信息在源码中设置断点、查看变量值等，从而更方便地进行调试工作。 总的来说就是用kotlin编写的代码部分及跟代码相关会存放在该文件夹内。 class.dex 应用的可执行文件，android的所有代码都集中在此 okhttp3 存放库文件 `okhttp3` 文件夹主要包含了 OkHttp3 库的相关类文件（`.class` 文件）。这些类文件是 OkHttp3 库的编译产物，是实现网络请求功能的核心代码。应用在运行时，会调用这些类文件中的方法来完成各种网络操作，比如发起 HTTP 请求、处理响应等。 网络请求功能实现 OkHttp3 提供了丰富的 API 来简化网络请求的过程，`okhttp3` 文件夹中的类文件实现了这些功能： 请求构建：通过 font style=background-color:rgb(187,191,196);Request/font 和 font style=background-color:rgb(187,191,196);Request.Builder/font 类，可以方便地构建不同类型的 HTTP 请求，如 GET、POST、PUT、DELETE 等，还能设置请求头、请求体等参数。 响应处理：font style=background-color:rgb(187,191,196);Response/font 类用于处理服务器返回的响应，包括获取响应状态码、响应头、响应体等信息。 连接管理：OkHttp3 会自动管理网络连接，font style=background-color:rgb(187,191,196);okhttp3/font 文件夹中的相关类负责处理连接的建立、复用和关闭，以提高网络请求的效率。 拦截器机制：OkHttp3 支持拦截器，开发者可以自定义拦截器来对请求和响应进行预处理和后处理。例如，添加统一的请求头、记录请求日志等。 依赖管理 在 Android 开发中，通常使用 Gradle 或 Maven 等构建工具来管理项目的依赖。当在项目中添加 OkHttp3 依赖时，构建工具会将 OkHttp3 库的文件下载并整合到项目中。`okhttp3` 文件夹就是这些依赖文件在 APK 中的体现，确保应用在运行时能够正常使用 OkHttp3 库的功能。 Proguard 代码混淆 + 防止反编译：ProGuard 会将 Java 字节码中的类名、方法名、变量名等标识符替换为简短的无意义名称，使反编译后的代码难以理解，增加了代码被逆向工程的难度，从而保护应用的知识产权和商业逻辑。 + 缩小 APK 体积：通过移除未使用的代码和资源，以及对代码进行优化，减少了 APK 文件的大小，这有助于应用更快地下载和安装，节省用户的流量和设备存储空间。 代码优化 + 字节码优化：ProGuard 会对字节码进行分析和优化，例如删除无用的指令、合并冗余的代码块等，使应用的执行效率更高，运行速度更快。 + 资源优化：它还可以对资源文件进行优化，如压缩图片、删除未使用的资源等，进一步减小 APK 的体积，并提高应用的性能。 生成相关文件 + 映射文件：在代码混淆过程中，ProGuard 会生成映射文件，记录原始代码中的标识符与混淆后标识符的对应关系。这个文件对于在出现问题时进行调试和错误定位非常有帮助，开发人员可以通过映射文件将混淆后的代码还原为原始代码，以便查找问题。 + 配置文件：`proguard` 文件夹中可能还包含配置文件，用于指定混淆和优化的规则。开发人员可以根据应用的具体需求，在配置文件中设置哪些类、方法或变量需要被保留，哪些可以进行混淆和优化等。","categories":["android-reserve/android"]},{"path":"/share/index.html","content":"share 下面是一些我觉得不错的文章 首先是正己大佬的入门课 AndroidMainfest.xml全解 007大佬的博客，东西比较杂，什么都有 白龙大佬的博客，对unidbg入门很有帮助，有加密算法的基础会更容易读 SeeFlowerX大佬的博客，白龙大佬博客中缺的部分可以在这里找到，不过是转载。这个大佬的东西多是一些进阶的东西 可以用来上手fridaobjection，不过最后几题的题解有些许问题 frida对native层hook的补充 8种主流壳的详解，不过是21年的，壳已经不一样了，主要是理解加壳思路，要有基础 然后就是三大主流网站 安全KER、吾爱破解、看雪论坛"}]